<!--
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-drawer-panel` contains a drawer panel and a main panel.  The drawer
and the main panel are side-by-side with drawer on the left.  When the browser
window size is smaller than the `responsiveWidth`, `core-drawer-panel`
changes to narrow layout.  In narrow layout, the drawer will be stacked on top
of the main panel.  The drawer will slide in/out to hide/reveal the main
panel.

Use the attribute `drawer` to indicate that the element is the drawer panel and
`main` to indicate that the element is the main panel.

Example:

    <core-drawer-panel>
      <div drawer> Drawer panel... </div>
      <div main> Main panel... </div>
    </core-drawer-panel>

The drawer and the main panels are not scrollable.  You can set CSS overflow
property on the elements to make them scrollable or use `core-header-panel`.

Example:

    <core-drawer-panel>
      <core-header-panel drawer>
        <core-toolbar></core-toolbar>
        <div> Drawer content... </div>
      </core-header-panel>
      <core-header-panel main>
        <core-toolbar></core-toolbar>
        <div> Main content... </div>
      </core-header-panel>
    </core-drawer-panel>

An element that should toggle the drawer will automatically do so if it's
given the `core-drawer-toggle` attribute.  Also this element will automatically
be hidden in wide layout.

Example:

    <core-drawer-panel>
      <core-header-panel drawer>
        <core-toolbar>
          <div>Application</div>
        </core-toolbar>
        <div> Drawer content... </div>
      </core-header-panel>
      <core-header-panel main>
        <core-toolbar>
          <core-icon-button icon="menu" core-drawer-toggle></core-icon-button>
          <div>Title</div>
        </core-toolbar>
        <div> Main content... </div>
      </core-header-panel>
    </core-drawer-panel>

To position the drawer to the right, add `rightDrawer` attribute.

    <core-drawer-panel rightDrawer>
      <div drawer> Drawer panel... </div>
      <div main> Main panel... </div>
    </core-drawer-panel>

@group Polymer Core Elements
@element core-drawer-panel
@homepage github.io
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../core-media-query/core-media-query.html">
<link rel="import" href="../core-selector/core-selector.html">

<dom-module id="core-drawer-panel">
  <link rel="stylesheet" href="core-drawer-panel.css">

  <template>
    <core-media-query query="[[mediaQuery]]" on-query-matches-changed="onQueryMatchesChanged">
    </core-media-query>

    <core-selector class-name="[[coreSelectorClass]]"
        attr-for-selected="id"
        on-core-activate="onSelect"
        selected="[[selected]]">

      <div id="main" style="[[mainStyle]]">
        <content select="[main]"></content>
        <div id="scrim"></div>
        <div id="edgeSwipeOverlay" class-name="[[swipeOverlayClass]]"></div>
      </div>

      <div id="drawer" style="[[drawerStyle]]">
        <content select="[drawer]"></content>
      </div>

    </core-selector>
  </template>

</dom-module>

<script>

  (function() {

    'use strict';

    function classNames(obj) {
      var classNames = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key]) {
          classNames.push(key);
        }
      }

      return classNames.join(' ');
    }

    Polymer({

      is: 'core-drawer-panel',

      /**
       * Fired when the narrow layout changes.
       *
       * @event core-responsive-change
       * @param {Object} detail
       * @param {boolean} detail.narrow true if the panel is in narrow layout.
       */

      /**
       * Fired when the selected panel changes.
       *
       * Listening for this event is an alternative to observing changes in the `selected` attribute.
       * This event is fired both when a panel is selected and deselected.
       * The `isSelected` detail property contains the selection state.
       *
       * @event core-select
       * @param {Object} detail
       * @param {boolean} detail.isSelected true for selection and false for deselection
       * @param {Object} detail.item the panel that the event refers to
       */

      properties: {

        coreSelectorClass: {
          computed: 'calcCoreSelectorClass(narrow, transition, dragging, rightDrawer)'
        },

        /**
         * The panel to be selected when `core-drawer-panel` changes to narrow
         * layout.
         *
         * @attribute defaultSelected
         * @type string
         * @default 'main'
         */
        defaultSelected: {
          type: String,
          value: 'main'
        },

        /**
         * If true, swipe from the edge is disable.
         *
         * @attribute disableEdgeSwipe
         * @type boolean
         * @default false
         */
        disableEdgeSwipe: {
          type: Boolean,
          value: false
        },

        /**
         * If true, swipe to open/close the drawer is disabled.
         *
         * @attribute disableSwipe
         * @type boolean
         * @default false
         */
        disableSwipe: Boolean,

        // Whether the user is dragging the drawer interactively.
        dragging: {
          value: false
        },

        drawerStyle: {
          computed: 'calcDrawerStyle(drawerWidth)'
        },

        /**
         * Width of the drawer panel.
         *
         * @attribute drawerWidth
         * @type string
         * @default '256px'
         */
        drawerWidth: {
          type: String,
          value: '256px'
        },

        // How many pixels on the side of the screen are sensitive to edge
        // swipes and peek.
        edgeSwipeSensitivity: {
          value: 15
        },

        /**
         * If true, ignore `responsiveWidth` setting and force the narrow layout.
         *
         * @attribute forceNarrow
         * @type boolean
         * @default false
         */
        forceNarrow: {
          observer: 'forceNarrowChanged',
          type: Boolean,
          value: false
        },

        mainStyle: {
          computed: 'calcMainStyle(narrow, rightDrawer, drawerWidth)'
        },

        mediaQuery: {
          computed: 'calcMediaQuery(forceNarrow, responsiveWidth)'
        },

        /**
         * Returns true if the panel is in narrow layout.  This is useful if you
         * need to show/hide elements based on the layout.
         *
         * @attribute narrow
         * @type boolean
         * @default false
         */
        narrow: {
          reflect: true,
          type: Boolean,
          value: false
        },

        // Whether the drawer is peeking out from the edge.
        peeking: false,

        /**
         * Max-width when the panel changes to narrow layout.
         *
         * @attribute responsiveWidth
         * @type string
         * @default '640px'
         */
        responsiveWidth: {
          type: String,
          value: '640px'
        },

        /**
         * If true, position the drawer to the right.
         *
         * @attribute rightDrawer
         * @type boolean
         * @default false
         */
        rightDrawer: {
          type: Boolean,
          value: false
        },

        /**
         * The panel that is being selected. `drawer` for the drawer panel and
         * `main` for the main panel.
         *
         * @attribute selected
         * @type string
         * @default null
         */
        selected: {
          reflect: true,
          type: String,
          value: null
        },

        swipeOverlayClass: {
          computed: 'calcSwipeOverlayClass(narrow, disableEdgeSwipe)'
        },

        // The attribute on elements that should toggle the drawer on tap,
        // also elements will automatically be hidden in wide layout.
        drawerToggleAttribute: {
          value: 'core-drawer-toggle'
        },

        // Whether the transition is enabled.
        transition: false

      },

      calcCoreSelectorClass: function(narrow, transition, dragging, rightDrawer) {
        return classNames({
          dragging: dragging,
          'narrow-layout': narrow,
          'right-drawer': rightDrawer,
          transition: transition
        });
      },

      calcDrawerStyle: function(drawerWidth) {
        return 'width:' + drawerWidth + ';';
      },

      calcMainStyle: function(narrow, rightDrawer, drawerWidth) {
        var style = '';

        style += 'left:' + ((narrow || rightDrawer) ? '0' : drawerWidth) + ';';
        style += 'right:' + (rightDrawer ? (narrow ? '' : drawerWidth) : '') + ';';

        return style;
      },

      calcMediaQuery: function(forceNarrow, responsiveWidth) {
        return forceNarrow ? '' : '(max-width: ' + responsiveWidth + ')';
      },

      calcSwipeOverlayClass: function(narrow, disableEdgeSwipe) {
        return classNames({
          hidden: !narrow || disableEdgeSwipe
        });
      },

      listeners: {
        click: 'onClick',
        down: 'downHandler',
        trackstart: 'trackStart',
        trackx: 'trackx',
        trackend: 'trackEnd',
        up: 'upHandler'
      },

      ready: function() {
        // Whether the browser has support for the transform CSS property.
        this.hasTransform = ('transform' in this.style);

        // Whether the browser has support for the will-change CSS property.
        this.hasWillChange = ('willChange' in this.style);

        // Avoid transition at the beginning e.g. page loads and enable
        // transitions only after the element is rendered and ready.
        this.transition = true;
      },

      /**
       * Toggles the panel open and closed.
       *
       * @method togglePanel
       */
      togglePanel: function() {
        if (this.isMainSelected()) {
          this.openDrawer();
        } else {
          this.closeDrawer();
        }
      },

      /**
       * Opens the drawer.
       *
       * @method openDrawer
       */
      openDrawer: function() {
        this.selected = 'drawer';
      },

      /**
       * Closes the drawer.
       *
       * @method closeDrawer
       */
      closeDrawer: function() {
        this.selected = 'main';
      },

      _responsiveChange: function(narrow) {
        this.narrow = narrow;

        if (this.narrow) {
          this.selected = this.defaultSelected;
        }

        this.setAttribute('touch-action', this.swipeAllowed() ? 'pan-y' : '');
        this.fire('core-responsive-change', {narrow: this.narrow});
      },

      onQueryMatchesChanged: function(e) {
        this._responsiveChange(e.detail.value);
      },

      forceNarrowChanged: function() {
        this._responsiveChange(this.forceNarrow);
      },

      swipeAllowed: function() {
        return this.narrow && !this.disableSwipe;
      },

      isMainSelected: function() {
        return this.selected === 'main';
      },

      startEdgePeek: function() {
        this.width = this.$.drawer.offsetWidth;
        this.moveDrawer(this.translateXForDeltaX(this.rightDrawer ?
            -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));
        this.peeking = true;
      },

      stopEdgePeek: function() {
        if (this.peeking) {
          this.peeking = false;
          this.moveDrawer(null);
        }
      },

      downHandler: function(e) {
        if (!this.dragging && this.isMainSelected() && this.isEdgeTouch(e)) {
          this.startEdgePeek();
        }
      },

      upHandler: function(e) {
        this.stopEdgePeek();
      },

      onClick: function(e) {
        var isTargetToggleElement = e.target &&
          this.drawerToggleAttribute &&
          e.target.hasAttribute(this.drawerToggleAttribute);

        if (isTargetToggleElement) {
          this.togglePanel();
        }
      },

      isEdgeTouch: function(e) {
        return !this.disableEdgeSwipe && this.swipeAllowed() &&
          (this.rightDrawer ?
            e.pageX >= this.offsetWidth - this.edgeSwipeSensitivity :
            e.pageX <= this.edgeSwipeSensitivity);
      },

      trackStart : function(e) {
        if (this.swipeAllowed()) {
          this.dragging = true;

          if (this.isMainSelected()) {
            this.dragging = this.peeking || this.isEdgeTouch(e);
          }

          if (this.dragging) {
            this.width = this.$.drawer.offsetWidth;
            this.transition = false;
            e.preventTap();
          }
        }
      },

      translateXForDeltaX: function(deltaX) {
        var isMain = this.isMainSelected();

        if (this.rightDrawer) {
          return Math.max(0, isMain ? this.width + deltaX : deltaX);
        } else {
          return Math.min(0, isMain ? deltaX - this.width : deltaX);
        }
      },

      trackx: function(e) {
        if (this.dragging) {
          if (this.peeking) {
            if (Math.abs(e.dx) <= this.edgeSwipeSensitivity) {
              return; // Ignore trackx until we move past the edge peek.
            }
            this.peeking = false;
          }
          this.moveDrawer(this.translateXForDeltaX(e.dx));
        }
      },

      trackEnd: function(e) {
        if (this.dragging) {
          this.dragging = false;
          this.transition = true;
          this.moveDrawer(null);

          if (this.rightDrawer) {
            this[(e.xDirection > 0) ? 'closeDrawer' : 'openDrawer']();
          } else {
            this[(e.xDirection > 0) ? 'openDrawer' : 'closeDrawer']();
          }
        }
      },

      transformForTranslateX: function(translateX) {
        if (translateX === null) {
          return '';
        }

        return this.hasWillChange ? 'translateX(' + translateX + 'px)' :
            'translate3d(' + translateX + 'px, 0, 0)';
      },

      moveDrawer: function(translateX) {
        var s = this.$.drawer.style;

        if (this.hasTransform) {
          s.transform = this.transformForTranslateX(translateX);
        } else {
          s.webkitTransform = this.transformForTranslateX(translateX);
        }
      },

      onSelect: function(e) {
        e.preventDefault();
        this.selected = e.detail.selected;
      }

    });

  }());

</script>
